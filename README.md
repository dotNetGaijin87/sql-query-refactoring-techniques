# SQL クエリリファクタリング手法

このリポジトリでは、SQL クエリのパフォーマンスと可読性を向上させるためのリファクタリング手法を紹介します。

## 内容

スクリプト 01 は、サンプルデータベーススキーマの作成とデート挿入するスクリプトです。</br>
このサンプルデータベースは後続のスクリプトで使用される。</br>
スクリプト 02 では、クエリ内のテーブルの役割を特定する方法を解説します。</br>
スクリプト 03 ～ 06 では、さまざまなリファクタリング手法を紹介します。</br>
最後のスクリプト 07 は、複雑なクエリのステップごとのリファクタリングを扱うケーススタディです。</br>

## 取り扱っている手法の一覧

- 手法＃１：ウィンドウ関数による無駄なテーブルアクセス削減
- 手法＃２：一時テーブルによる重複スキャン削減
- 手法＃３：CASE 式による一括更新
- 手法＃４：最上位クエリでの DISTINCT をサブクエリに移動
- 手法＃５：最上位クエリでの GROUP BY をサブクエリに移動
- 手法＃６：複数 IF-ELSE を CASE 式で解決
- 手法＃７：防御 IF をなくす
- 手法＃８：IF ... IS NULL を ISNULL 関数で解決
- 手法＃９：優先順位 UPDATE を CASE 式で解決
- 手法＃１０：SELECT 文の複数サブクエリを GROUP BY と CASE 式に置換
- 手法＃１１：SELECT 文の自己結合をウィンドウ関数に置換

## リファクタリング前に理解すべき基礎知識

SQL は宣言型言語であるため、我々が書いたクエリは「どのデータが欲しいのか」をデータベースエンジンに伝えるヒントに過ぎない。
しかし、そのクエリをどのように実行するかはデータベース側の判断次第である。
例えば、サブクエリ内で 2 つのテーブルを JOIN しても、データベースエンジンが「それは効率的ではない」と判断すれば、クエリ全体を別の形に書き換えて実行することもあります。
とはいえ、クエリはできるだけシンプルに書くべきです。なぜなら、データベースは限られた時間の中で最適な実行計画を見つけ、クエリを実行しなければならないからです。
クエリが複雑すぎたり、間違った書き方をすると、パフォーマンスに悪影響を与えてしまう。
そのため、サブクエリ・ウィンドウ関数・CTE などの手法を活用すれば、クエリ実行というデータベースの仕事が楽になる。

## リファクタリング後のクエリ性能をどうやって評価するか

リファクタリングした後、その変更が本当にパフォーマンス改善につながったのかを確認することは非常に重要である。</br>
そのためには、定量的な性能指標を使って比較する必要がある。

SQL Server では評価するため様々の方法があるがもっとも一般的なのは STATISTICS IO, TIME である。

```SQL
SET STATISTICS IO, TIME ON;
```

上記を設定して、クエリを実行すれば以下の情報を取得できる：

- 経過時間：実行完了までにかかった時間
- CPU 時間：CPU が実際に処理に使われた時間
- 論理読み取り数：キャッシュから読み取られたページ数
- 物理読み取り数：ディスクから直接読み取られたページ数
- TempDB 使用量：一時領域の利用状況</br>
  ※ページは 8KB の論理単位で構成されている。

ここでは主に「論理読み取り数」を使って評価する。
リファクタリング後、論理読み取り数が下がればパフォーマンスが上がったと分かる。

## 手法の例

```SQL
--================================================================================
--  手法＃６：複数IF-ELSEをCASE式で解決
--================================================================================

--------------------------------
-- BEFORE
--------------------------------
DECLARE @task_id INT;
DECLARE @due_date DATE;
DECLARE @status_id INT;
DECLARE @current_date DATE = '2025-06-30'; -- 一貫性のため固定日付を使用

DECLARE cur_tasks CURSOR FOR
SELECT task_id, due_date
FROM task
WHERE status_id IN (2, 3, 4);

OPEN cur_tasks;

FETCH NEXT FROM cur_tasks INTO @task_id, @due_date;

WHILE @@FETCH_STATUS = 0
BEGIN
    SET NOCOUNT ON;

    IF @due_date < @current_date
        SET @status_id = 4; -- 遅延
    ELSE IF @due_date < DATEADD(DAY, -1, @current_date)
        SET @status_id = 3; -- 遅延のリスクあり
    ELSE
        SET @status_id = 2; -- 順調

    UPDATE task
		SET status_id = @status_id
    WHERE task_id = @task_id;

    FETCH NEXT FROM cur_tasks INTO @task_id, @due_date;
END;

CLOSE cur_tasks;
DEALLOCATE cur_tasks;
GO


--------------------------------
-- AFTER
--------------------------------
DECLARE @current_date DATE = '2025-06-30'; -- 一貫性のため固定日付を使用

UPDATE task
	SET status_id =
		CASE
			WHEN due_date < @current_date THEN 4 -- 遅延
			WHEN due_date < DATEADD(DAY, -1, @current_date) THEN 3 -- 遅延のリスクあり
			ELSE 2 -- 順調
		END
	WHERE status_id IN (2, 3, 4);
GO
```
